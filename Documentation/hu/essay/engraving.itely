@c -*- coding: utf-8; mode: texinfo; -*-

@ignore
    Translation of GIT committish: e5d3fb33ceaec6d10e06af0c667e4e982a0028ce

    When revising a translation, copy the HEAD committish of the
    version that you are working on.  For details, see the Contributors'
    Guide, node Updating translation committishes..
@end ignore

@c \version "2.23.8"

@node A kottaszedés
@chapter A kottaszedés
@translationof Music engraving

Ez az esszé leírja, miért született a LilyPond, és hogyan képes ilyen gyönyörű
kottákat előállítani.


@c TODO:
@c remove 3mm eps bounding box left padding for Sarabande (This will
@c     require adding a new snippet option to lilypond-book.py
@c check formatting of HTML output

@menu
* A LilyPond története::
* A kottaszedés fortélyai::
* Az automatizált kottaszedés::
* Building software::
* Putting LilyPond to work::
* Engraved examples (BWV 861)::
@end menu

@node A LilyPond története
@section A LilyPond története
@translationof The LilyPond story

Mielőtt a LilyPondot koncerteken használt csodaszép kották szedésére kezdtük
volna használni, mielőtt zenetudományi dokumentumok zenei idézeteit vagy akár
egyszerű dallamokat le lehetett volna vele kottázni, mielőtt szerte a világon a
felhasználók széles körben kezdték volna használni, vagy ez az esszé
megszületett volna, a LilyPond története egy kérdéssel kezdődött:

@quotation
Miért nem adják vissza a számítógép által szedett kották a kézzel szedett kották
szépségét és kiegyensúlyozottságát?
@end quotation

@noindent
Erre többnyire választ kaphatunk, ha górcső alá vesszük a következő két kottát.
Az első példa egy gondosan kézzel szedett kotta 1950-ből, a második egy modern,
számítógéppel szedett kiadás.

@ifnottex
@quotation
@noindent
Bärenreiter BA 320, @copyright{}1950:

@sourceimage{baer-suite1-fullpage,,}
@end quotation

@quotation
@noindent
Henle no. 666, @copyright{}2000:

@sourceimage{henle-suite1-fullpage,,}
@end quotation
@end ifnottex

J. S. Bach első, csellóra írt szólószvitjének két kiadása hangról hangra
megegyezik, mégis megjelenésükben merőben különbözőek, különösen, ha
kinyomtatjuk és megszokott távolságból szemléljük őket. Próbáljuk meg mindkét
kottapéldát elolvasni, illetve játszani belőlük, és meg fogjuk állapítani, hogy
a kézzel szedett kotta használata kellemesebb. Folyékonysága és dinamikája egy
élő, lélegző zenemű érzetét kelti, miközben az újabb kiadás hidegnek és
mechanikusnak hat.

Nehéz egyből észrevenni, miben rejlik a különbség a kották között. Az új kotta
első ránézésre rendezett és pontos, talán még „jobb” is, mivel számítógéphez
illőbb és egységes a megjelenése. Ez gondolkodóba ejtett minket egy időre.
Javítani akartunk a számítógép által szedett kottaképen, de ehhez előbb rá
kellett jönnünk, mi volt a gond vele.

A válasz az új kotta precíz, matematikai pontosságú egyformaságában rejlik.
Keressük csak meg minden sor közepén az ütemvonalakat: a kézzel szedett
változatban az ütemvonalak elhelyezkedése természetes módon változik, míg a
számítógép szinte pontosan egymás alá, középre szedte őket. Ezt mutatja be a
következő egyszerűsített ábra, melyen a kézzel (balra), ill. a komputerrel
szedett változat (jobbra) elrendezése látható:

@quotation
@iftex
@sourceimage{pdf/page-layout-comparison,,}
@end iftex
@ifnottex
@sourceimage{page-layout-comparison,,}
@end ifnottex
@end quotation
@noindent

A számítógép által előállított szedésben még az egyes kottafejek is függőlegesen
egymáshoz lettek igazítva, ami azt az érzetet kelti, mintha a dallamvonal
eltűnne egy szimbólumokból álló merev rács mögött.

További különbségek is vannak: a kézzel szedett változat függőleges vonalai
erősebbek, a kötőívek szorosabban tapadnak a kottafejekhez, és a gerendák
szögeiben is nagyobb változatosság figyelhető meg. Noha az ilyen részletes
elemzés szőrszálhasogatásnak tűnhet, végeredménye egy olyan kotta, ami
egyszerűbben olvasható. A számítógépes kottában minden sor szinte egyforma, és
ha a zenész egy pillanatra máshová tekint, hamar elveszítheti a tájékozódást az
oldalon.

A LilyPond megalkotásának célja az volt, hogy kiküszöböljük a többi kottaszedő
szoftver szépséghibáit, és segítségével olyan kottákat lehessen előállítani,
melyek szépsége a legigényesebb kézzel szedett kottákéval vetélkedik.

@iftex
@page
@noindent
Bärenreiter BA 320, @copyright{}1950:

@sourceimage{baer-suite1-fullpage-hires,16cm,}
@page
@noindent
Henle no. 666, @copyright{}2000:
@sp 3
@sourceimage{henle-suite1-fullpage-hires,16cm,}
@page
@end iftex

@node A kottaszedés fortélyai
@section A kottaszedés fortélyai
@translationof Engraving details

@cindex engraving
@cindex typography, music
@cindex music typography
@cindex plate engraving
@cindex music engraving

A zeneművek nyomdai előkészítését @emph{kottaszedésnek} nevezik. Ez a kifejezés
a kották nyomtatásának  hagyományos, kézi módszerére utal.@footnote{A régi idők
nyomdászai különböző technikákat próbáltak ki, mint például a kézzel metszett fa
nyomóformák (nyomódúc), a mozgatható betű- és nyomóelemek, illetve a gravírozott
vékony fémlemezek. A mozgatható betű- és nyomóelemekkel való szedésnek megvolt
az az előnye, hogy gyorsan bele lehetett javítani és egyszerűen lehetett
szöveget is beleilleszteni. De csak a fémlemezre végzett hangjegymetszés tette
lehetővé a hibátlan elrendezést és az új kottaelemek gyors bevezetését. Végül ez
utóbbi technika lett a szabvány, és még a 20. század elején is ez volt a
helyzet, pár korálkönyv és daloskönyv kivételével, ahol a sablonelemek
használatát annak gazdaságossága és gyorsasága indokolta.} Ez a folyamat még a
20. században első felében is úgy nézett ki, hogy a kotta elemeit kivágták, majd
tükrözve belemélyesztették egy cink- vagy ónlemezbe. A lemezre ezután festéket
hordtak fel, és a festék a bemélyedésekben maradt. A lemez a papírra rányomva a
kotta képét adta. A metszést teljesen kézzel végezték, és bárminemű javítás
nagyon körülményes volt, így a kottakép elsőre tökéletes kellett, hogy legyen. A
kottaszedés tudománya nagyon különleges szakma, ahol a kézművesnek körülbelül öt
éves képzést kellett elvégeznie, mielőtt a mester címet kérvényezhette. További
öt év volt szükséges ahhoz, hogy a szakma minden csínját-bínját valóban magáénak
tudhassa.

@quotation
@iftex
@sourceimage{hader-slaan,,7cm}
@end iftex
@ifnottex
@sourceimage{hader-slaan,,}
@end ifnottex
@end quotation

A LilyPond megalkotását azok a kézzel szedett kották inspirálták, amelyeket a
20. század közepe felé az európai kottakiadók (többek között Bärenreiter, Duhem,
Durand, Hofmeister, Peters és Schott) hoztak forgalomba. Munkásságukat bizonyos
szempontból a hagyományos kottaszedés csúcsának lehet tekinteni. Kiadványaik
tanulmányozásával rengeteget tanultunk arról, mik az ismertetőjelei egy szép
tipográfiájú kottának, és milyen szempontokat szeretnénk a LilyPonddal utánozni.

@c Now all newly printed music is produced with computers.  This has
@c obvious advantages: prints are cheaper to make, editorial work can be
@c delivered by email, and the original data can be easily stored.
@c Unfortunately, computer-generated scores rarely match the quality of
@c hand-engraved scores.  Instead, computer printouts have a bland,
@c mechanical look, which makes them unpleasant to play from.

@menu
* A kottában használt betűtípusok::
* Optikai kiegyenlítettség::
* Pótvonalak::
* Optikai nagyság::
* Miért szükséges ez a nagy felhajtás?::
@end menu

@node A kottában használt betűtípusok
@unnumberedsubsec A kottában használt betűtípusok
@translationof Music fonts

A lenti ábra jól mutatja a különbséget egy hagyományosan és egy számítógép által
szedett kottaelem közt. A bal oldali képen egy beszkennelt b módosítójel látható
egy kézi Bärenreiter kiadásból, míg a jobb oldali ugyanennek a zeneműnek
2000-ben kiadott változatából származik. Noha mindkét képet ugyanolyan árnyalatú
tintával nyomtatták, a régebbi verzió sötétebb: a kottasorok vonalai
vastagabbak, és a Bärenreiter b-je gömbölyded, majdhogynem érzékien kerek. A
jobb oldali kép vonalai ezzel szemben vékonyabbak, elrendezése szögletes, sarkai
élesek.

@multitable @columnfractions .25 .25 .25 .25
@item @tab
@ifnotinfo
@iftex
@sourceimage{baer-flat-gray,,4cm}
@end iftex
@ifnottex
@sourceimage{baer-flat-gray,,}
@end ifnottex

@tab
@iftex
@sourceimage{henle-flat-gray,,4cm}
@end iftex
@ifnottex
@sourceimage{henle-flat-gray,,}
@end ifnottex

@end ifnotinfo
@ifinfo
@sourceimage{henle-flat-bw,,}
@sourceimage{baer-flat-bw,,}
@sourceimage{lily-flat-bw,,}
@end ifinfo


@item @tab
Bärenreiter (1950)
@tab
Henle (2000)

@end multitable

@cindex musical symbols
@cindex font
@cindex blackness
@cindex balance

Amikor úgy döntöttük, hogy írunk egy kottaszedő programot, nem volt olyan,
szabad felhasználású zenei betűtípus, ami jól passzolt volna kedvenc kottáink
elegáns kottaképéhez. Ezen felbuzdulva megalkottunk egy zenei szimbólumokból
álló betűtípust, amely a kézzel szedett kották szemrevaló kinézetét veszi
alapul. A betűtípus megtervezése során szerzett tapasztalatok nélkül soha nem
ismertük volna fel, milyen csúnyák is azok a betűtípusok, amiket eleinte
csodáltunk.

Lent két zenei betűkészletre láthatunk példát: a felső a Sibelius alapbeállítású
készlete (@emph{Opus}), az alsó a LilyPondé.

@quotation
@iftex
@sourceimage{pdf/OpusAndFeta,,}
@end iftex
@ifnottex
@sourceimage{OpusAndFeta,,}
@end ifnottex
@end quotation

A LilyPond kottaelemei vastagabbak, valamint vastagságuk konzisztensebb, ami
miatt jóval egyszerűbb az olvasásuk. A vonalaknak, mint például a negyed szünet
szárnyai, nem hegyes végük van, hanem finoman legömbölyített. Ennek oka, hogy a
hegyes végek a hagyományos nyomóformán nagyon törékenyek, és a használat közben
gyorsan elkopnak. Összefoglalva, a jelkészlet teltségét gondosan össze kell
hangolni a vonalak (gerendák, ívek) vastagságával, hogy erős, mégis
kiegyensúlyozott összképet kapjunk.

Vegyük észre továbbá, hogy a félkotta feje nem ellipszis, hanem enyhén rombusz
alakú. A b módosítójel függőleges szára felfelé némileg kiszélesedik. A
keresztet és a feloldójelet egyszerűbb távolról megkülönböztetni, mert ferde
vonalaiknak eltérő a dőlésszöge, illetve függőleges vonalaik különböző
vastagságúak.

@node Optikai kiegyenlítettség
@unnumberedsubsec Optikai kiegyenlítettség
@translationof Optical spacing

A kották vízszintes elrendezésénél a mindenkori hangjegy hosszúságának kell
visszatükröződnie.  Amint a fenti Bach-szvit példáján már megfigyelhettük, sok
modern kottánál a hangjegyek hosszának ábrázolása a matematikai precizitás felé
törekszik, ami nem túl szép eredményhez vezet.  A következő példában bemutatjuk
Önöknek ugyanazt a motívumot kétszer: először matematikai pontossággal, másodszor
ugyanezt kijavítva. Melyik példa tetszik Önnek jobban?

@cindex optical spacing

@lilypond
\paper {
  ragged-right = ##t
  indent = #0.0
}

music = {
   c'4 e''4 e'4 b'4
   \stemDown
   b'8[ e'' a' e'']
   \stemNeutral
   e'8[ e'8 e'8 e'8]
}
\score
{
  \music
  \layout {
    \context {
      \Staff
      \override NoteSpacing.stem-spacing-correction = #0.0
      \override NoteSpacing.same-direction-correction = #0.0
      \override StaffSpacing.stem-spacing-correction = #0.0
    }
  }
}
@end lilypond

@lilypond
\paper {
  ragged-right = ##t
  indent = #0.0
}

music = {
   c'4 e''4 e'4 b'4 |
   \stemDown
   b'8[ e'' a' e'']
   \stemNeutral
   e'8[ e'8 e'8 e'8]
}

\score
{
  \music
  \layout {
    \context {
      \Staff
      \override NoteSpacing.stem-spacing-correction = #0.6
    }
  }
}
@end lilypond

@cindex regular rhythms
@cindex regular spacing
@cindex spacing, regular

Ezen kottarészlet egyforma hosszúságú hangjegyeket használ.
A hangjegyek közti távolságnak tükröznie kellene ezt.
Sajnos a szemünk becsap: nem csak az egymást követő kottafejek
távolságát kell figyelembe kell venni, hanem a szárukat is.
Tehát egymás után következő fölfelé-lefelé szárú hangjegyeket
kicsit távolabb kell helyezni egymástól, míg a lefelé-fölfelé
kombináció szűkebb távolságot kíván, és az egész még függ a
hangjegyek függőleges pozíciójától.
Az alsó példa ezeket a korrektúraelveket tükrözi.
Ellenben a felső példán a hangjegyek alsó-felső irányba váltakozása
olyan érzetet kelt, mintha összegubancolódtak volna.
Az alsó példa ezeket a szabályokat tükrözi. Ellenben a felső példa az olvasó
szemében olyan érzetett kelt, mintha alul-fölül a kottafejek egy csomóban
lennének. Egy kottaszedő mester ezt a beosztást úgy igazítaná el, hogy annak az
olvasása kellemes legyen.

A Lilypond beosztásért felelős algoritmusa úgy kalkulál, hogy az ütemvonalat is
figyelembe veszi, ami miatt az utolsó hangjegy a fenti példában több helyet kap,
ezért nem kelti a zsúfoltság hatását. Egy szár lent nem szorulna erre a
beosztásra.

@node Pótvonalak
@unnumberedsubsec Pótvonalak
@translationof Ledger lines

@cindex ledger lines
@cindex collisions

A pót- (esetleg: segéd-) vonalak mindig kihívás elé állítják a tipográfiát:
miattuk nehezebb a hangjegyeket sűrűn elrendezni és a hangmagasságot egy gyors
pillantással meg kell tudni állapítani. A lentebb található példában láthatjuk,
hogy a pótvonalnak vastagabbnak kell lennie mint egy normál kottavonalnak és egy
tanult kottaszedő a pótvonalat lerövidíti azért, hogy a módosító jeleknek
maradjon hely. Ezt a tulajdonságot mi beleépítettük a Lilypondba.

@multitable @columnfractions .25 .25 .25 .25
@item @tab

@iftex
@sourceimage{baer-ledger,3cm,}
@end iftex
@ifnottex
@sourceimage{baer-ledger,,}
@end ifnottex

@tab

@iftex
@sourceimage{lily-ledger,3cm,}
@end iftex
@ifnottex
@sourceimage{lily-ledger,,}
@end ifnottex

@end multitable


@node Optikai nagyság
@unnumberedsubsec Optikai nagyság
@translationof Optical sizing

A kottákat különböző méretben nyomják. Eredetileg ehhez különböző méretű
kliséket  gyártottak, ami egyben azt jelenti, hogy minden klisé olyan minőségű
volt, hogy a saját méretében a legideálisabb képet adja. A digitális fonttal
tudjuk a hangjegyek kontúrját matematikusan felnagyítani illetve kicsinyíteni
azért, hogy a tetszés szerinti méretben elő tudjuk állítani, aminek sok előnye
van. Azonban kis méretben a szimbólumok túl vékonynak hatnak.

A Lilypond számára különböző vastagságú szedéstípusokat készítettünk, melyek egy
bizonyos kottaméretnek felelnek meg. Az itt látható Lilypond kottaszedés 26-os
méretű:

@quotation
@iftex
@sourceimage{pdf/size26,,23mm}
@end iftex
@ifnottex
@sourceimage{size26,,}
@end ifnottex
@end quotation

@noindent
Itt ugyanazok a kották 11-es méretben, utána 236%-al nagyítva. hogy a kép
pontosan abban a méretben jelenjen meg, mint az előbbi.

@quotation
@iftex
@sourceimage{pdf/size11,,23mm}
@end iftex
@ifnottex
@sourceimage{size11,,}
@end ifnottex
@end quotation

@noindent
Kisebb méretnél a Lilypond arányosan vastagított kottavonalakat használ a kitűnő
olvashatóság érdekében.

Ez teszi lehetővé különböző méretű kottasorok békés egymás mellett élését
egy oldalon:

@c Grieg's Violin Sonata Op. 45
@lilypond[indent=1.5\cm]
global = {
  \time 6/8
  \key c \minor
}

\score {
  <<
    \new Staff \with {
      \magnifyStaff #2/3
    }
    \relative {
      \global
      \set Staff.instrumentName = "Violin"
      c'8.(\f^> b16 c d) ees8.(^> d16 c b)
      g8.(^> b16 c ees) g8-.^> r r
      R2.
    }
    \new PianoStaff <<
      \set PianoStaff.instrumentName = "Piano"
      \new Staff \relative {
        \global
        s2.
        s4. s8 r8 r16 <c' f aes c>
        <c f aes c>4.^> <c ees g>8 r r
      }
      \new Staff \relative {
        \global
        \clef "bass"
        <<
        {
          \once \override DynamicText.X-offset = #-3
          <ees g c>2.~->^\f
          <ees g c>4.~ <ees g c>8
        } \\ {
          <c g c,>2.~
          <c g c,>4.~ <c g c,>8
        }
        >>
        r8 r16 <f, c' aes'>16
        <f c' aes'>4.-> <c' g'>8 r r
      }
    >>
  >>
}
@end lilypond


@node Miért szükséges ez a nagy felhajtás?
@unnumberedsubsec Miért szükséges ez a nagy felhajtás?
@translationof Why work so hard?

Musicians are usually more absorbed with performing than with studying
the looks of a piece of music, so nitpicking typographical details may
seem academic.  But it is not.  Sheet music is performance material:
everything is done to aid the musician in letting her perform better,
and anything that is unclear or unpleasant to read is a hindrance.

Traditionally engraved music uses bold symbols on heavy staff to create
a strong, well-balanced look that stands out well when the music is far
away from the reader: for example, if it is on a music stand.  A careful
distribution of white space allows music to be set very tightly without
crowding symbols together.  The result minimizes the number of page
turns, which is a great advantage.

This is a common characteristic of typography.  Layout should be pretty,
not only for its own sake, but especially because it helps the reader in
his task.  For sheet music this is of double importance because musicians
have a limited amount of attention.  The less attention they need for
reading, the more they can focus on playing the music.  In other words,
better typography translates to better performances.

These examples demonstrate that music typography is an art that is
subtle and complex, and that producing it requires considerable
expertise, which musicians usually do not have.  LilyPond is our
effort to bring the graphical excellence of hand-engraved music to
the computer age, and make it available to normal musicians.  We
have tuned our algorithms, font-designs, and program settings to
produce prints that match the quality of the old editions we love
to see and love to play from.


@node Az automatizált kottaszedés
@section Az automatizált kottaszedés
@translationof Automated engraving

@cindex engraving, automated
@cindex automated engraving

Ebben a szakaszban arról lesz szó, mi szükséges egy program megírásánál, ami az
elkészült kotta szedéstükrét meghatározza. Egy módszer ami elmagyarázza a
számítógépnek a szép  szedéstükör  ismérveit és részletesen összehasonlítja a
hagyományos módon előállított kottával.

@menu
* Szépségverseny::
* A minőség javítása a kottaképek összehasonlításával::
* Mindent szépen elrendezünk::
@end menu

@node Szépségverseny
@unnumberedsubsec Szépségverseny
@translationof Beauty contests

Hogyan kell hát a tipográfiát felhasználnunk? Másképpen mondva: A három egymást
követő kötőívből melyiket válasszuk ki?

@lilypond
\relative {
  \clef bass
  \once \override Slur.positions = #'(1.5 . 1)
  e8[( f] g[ a b d,)] r4
  \once \override Slur.positions = #'(2 . 3)
  e8[( f] g[ a b d,)] r4
  e8[( f] g[ a b d,)] r4
}
@end lilypond

Sajnos kevés könyv állt rendelkezésünkre a kottaszedés művészetéről. Így csak
ökölszabályokat állíthattunk fel és egyes példákat tudunk bemutatni. Ezek a
szabályok ugyan informatívak lehetnek de túl messze távolodnak attól az
algoritmustól, amit a programba beépítünk. Ahol a felhasznált irodalom által
kívánt szabályokat felhasználtuk, az algoritmust nagyon sok manuális beállítás
befolyásolja. Minden lehetséges esetet kielemezni nagy munka lenne és
legtöbbször nem meríti ki az összes lehetőséget:

@quotation
@iftex
@sourceimage{ross-beam-scan,7cm,}
@end iftex
@ifnottex
@sourceimage{ross-beam-scan,,}
@end ifnottex
@end quotation

(Kép forrása: Ted Ross, @emph{The Art of Music Engraving})

Ahelyett, hogy megpróbálkoznánk azzal, hogy minden lehetséges esethez egy hozzá
pontosan felvázolni, hogy a legtetszetősebbet ki tudja választani a szoftver.
Utána felállítunk a lehetséges változatokból egy „csúnyasági ranglistát” és
kiválasztjuk a legkevésbé csúnyát.

Például itt a legátó ívet 3 lehetséges pályán rajzolta fel és mindegyik változat
rondaságát pontozta a program. Az első példa 15,39 pontot kapott mert az ív
félbevágott egy kottafejet.

@lilypond
\relative {
  \clef bass
  \once \override Slur.positions = #'(1.5 . 1)
  e8[(_"15.39" f] g[ a b d,)] r4
}
@end lilypond

A második példa már szebb, de az ív végei nem érintik sem a kezdő sem a befejező
hang bogyóját. Ebben az esetben 1,71 pontot kap a bal 9,37 pontot a jobb oldal
és további két pontot mivel az ív felfelé tart miközben a dallam ereszkedik.
Összesen 13,08 pont:

@lilypond
\relative {
  \clef bass
  \once \override Slur.positions = #'(2 . 3)
  e8[(_"13.08" f] g[ a b d,)] r4
}
@end lilypond

Az utolsó ív 10,04 pontot kap mivel jobb oldalon hagyott egy rést és 2 pontot a
fent található lejtésért/emelkedésért tehát a három közül ez a legszebb.

@lilypond
\relative {
  \clef bass
  e8[(_"12.04" f] g[ a b d,)] r4
}
@end lilypond

Ez a technika teljesen általános és felhasználja a program az optikai kinézet
javításáért különböző ívek összekombinálásánál kötőíveknél, pontok
elhelyezésénél, akkordoknál illetve sor és oldaltöréseknél. Ezeknek a
döntéseknek az eredményeit össze tudjuk vetni a kézzel szedett kották
kinézetével.

@node A minőség javítása a kottaképek összehasonlításával
@unnumberedsubsec A minőség javítása a kottaképek összehasonlításával
@translationof Improvement by benchmarking

A Lilypond újabb verziói lépésről-lépésre jobbak lettek miközben folyamatosan a
kézzel szedett kottákkal lettek összehasonlítva.

Itt látható egy kézzel szedett referenciapélda:

@iftex
@sourceimage{baer-sarabande-hires,16cm,}
@end iftex
@ifnottex
@sourceimage{baer-sarabande,,}
@end ifnottex

@noindent
és ugyanez a sor így néz ki a Lilypond egyik régi verziójával (1.4-es verzió
2001 május):

@iftex
@sourceimage{pdf/lily14-sarabande,16cm,}
@end iftex
@ifnottex
@sourceimage{lily14-sarabande,,}
@end ifnottex

@noindent A Lilypond 1.4-es kiadása minden esetre olvashatóbb de egy részletes
összevetés az eredetivel a formázás sok apró hibájára mutat rá:

@iftex
@sourceimage{lily14-sarabande-annotated-hires,16cm,}
@end iftex
@ifnottex
@sourceimage{lily14-sarabande-annotated,,}
@end ifnottex

@itemize @bullet
@item Az ütemmutató előtt nincs elég hely
@item A gerendás hangjegyek szárai túl hosszúak
@item A második és negyedik ütem túl keskeny
@item A kötőívek idétlenek
@item A trillajel túl nagy
@item A szárak vékonyak
@end itemize

@noindent
(Ezenkivül van még két hiányzó kottafej, több hiányzó
közreadói megjegyzés és egy fals hangmagasság!)

Igazítva az oldalkinézeti szabályokon és a betűtípusdizájnon
az újabb kiadások rendkívül sokat javultak.
Hasonlítsa össze ugyanazt a referenciapéldát
az aktuális Lilypond verzióval (@version{}):

@iftex
@sourceimage{baer-sarabande-hires,16cm,}
@end iftex
@ifnottex
@sourceimage{baer-sarabande,,}
@end ifnottex

@lilypond[staffsize=17.5,line-width=15.9\cm]
\relative c {
  \clef "bass"
  \key d \minor
  \time 3/4
  \mergeDifferentlyDottedOn
  <<
    { \slurDashed d8.-\flageolet( e16) e4.-\trill( d16 e) }
     \\
    { d4_2 a2 }
  >>
  \slurDashed
  <f' a, d,>4. e8( d c)
  \slurSolid
  bes8 g' f e16( f g_1 a_2 bes_3 d,_2)
  \slurDashed
  cis4.-\trill b8_3( a g)
  <<
    { \slurDashed d'8.( e16) e4.-\trill( d16 e) }
     \\
    { <f, a>4 a2 }
  >>
}
@end lilypond

@noindent
Az aktuális kiadás ugyan még nem a referencia klónja, de jobban megközelíti már a
nyomdai minőséget.

@node Mindent szépen elrendezünk
@unnumberedsubsec Mindent szépen elrendezünk
@translationof Getting things right

A Lilypond képességeit mérhetjük avval is, hogy
összehasonlítjuk a kereskedelemben kapható programokkal.
Ebben az esetben a Finale 2008-at vettük, egyike a legismertebb
kottaszedő programoknak különösen Észak-Amerikában.
A Sibelius a Finale fő vetélytársa, legfőképp Európában ismert.

Összehasonlításunkhoz a Wohltemperiertes Clavier I. kötetének
g-moll fúgáját (BWV 861) választottuk, melynek nyitótémája:

@lilypond
\relative {
  \key g \minor
  \clef "treble_8"
  r8 d' ees g, fis4 g
  r8 a16 bes c8 bes16 a bes8
}
@end lilypond

@noindent

Összehasonlításunkban a darab utolsó 7 ütemét írtuk meg Finale
és a Lilypond segítségével.  Ez az a pont, ahol a téma háromszólamú
szűkmenetben tér vissza és megy át a zárószakaszba.
A Finale verziónál ellenálltunk a kísértésnek, hogy a normáltól
eltérő dolgokat korrigáljuk, mivel meg akarjuk mutatni azokat a
dolgokat, amit ezek a programok külön beavatkozás nélkül rendesen
csinálnak meg.  Az egyetlen változtatás csak a méretnél volt,
hiszen hozzáigazítottuk ennek az esszének az oldalméretéhez,
valamint két sorra korlátoztuk a kottát annak érdekében, hogy az
összehasonlítás egyszerűbb legyen.  Alapértelmezett beállításoknál
a Finale két háromütemes sort és egy záró teljes szélességű,
csak egy ütemet tartalmazó sort állítana elő.

Rengeteg különbség van a két kotta között: először a Finale, majd a Lilypondé
látható:

@iftex
@sourceimage{pdf/bwv861mm28-29,14cm,}
@end iftex
@ifnottex
@sourceimage{bwv861mm28-29,,}
@end ifnottex

@lilypond[staffsize=19.5,line-width=14\cm]
global = { \key g \minor }

partI = \relative {
  \voiceOne
  fis'8 d' ees g, fis4 g
  r8 a16 bes c8 bes16 a d8 r r4
}

partII = \relative {
  \voiceTwo
  d'4 r4 r8 d'16 c bes8 c16 d
  ees8 d c ees a, r r4
}

partIII = \relative {
  \voiceOne
  r2 r8 d' ees g, fis4 g r8 a16 bes c8 bes16 a
}

partIV = \relative {
  \voiceTwo
  d4 r r2
  r8 d ees g, fis4 a
}

\score {
  <<
    \set Score.currentBarNumber = #28
    \new PianoStaff <<
      \new Staff = "RH" <<
        \global
        \new Voice = "voiceI" { \partI }
        \new Voice = "voiceII" { \partII }
      >>
      \new Staff = "LH"
      <<
        \clef "bass"
        \global
        \new Voice = "voiceIII" { \partIII }
        \new Voice = "voiceIV" { \partIV }
      >>
    >>
  >>
  \layout {
    \context {
      \Staff
      \remove Time_signature_engraver
    }
    \context {
      \PianoStaff
      \override StaffGrouper.staff-staff-spacing.padding = #1
    }
  }
}
@end lilypond

Pár hiba a teljesség igénye nélkül, amit a külön nem szerkesztett Finale szedés
tartalmaz:
@itemize @bullet
@item A legtöbb gerenda túl messzire távolodik a kottasortól.  A gerenda, ami a
a rendszer közepére mutat, általában oktáv hosszúságú kellene legyen, de a
kottaszedő lekurtítja azt, ha a gerendák polifónia esetén kilógnak.  A Finale
gerendázásért felelős egységét a  programban található Patterson Beams Plugin
tudja feljavítani, de ezt a lépést ennél a példánál elhagytuk.
@item A Finale nem találja meg a szorosan egymáshoz illeszkedő hangjegyek
helyét, ezért a kotta nehezen olvasható, főleg ha az alsó és felső szólam
időlegesen helyet cserél.

@lilypond
collide = \once \override NoteColumn.force-hshift = #0

\score {
  <<
    \new Voice = "sample" \relative c''{
      \key g \minor
      <<
        { \voiceOne g4 \collide g4 }
        \new Voice { \voiceTwo bes \collide bes }
      >>
    }
    \new Lyrics \lyricsto "sample" { "good " " bad" }
  >>
}
@end lilypond
@item A Finale minden szünetjelet pontosan ugyanabba az állásba pozicionál.
Kézzel állíthatók ugyan szükség esetén, de a program nem figyel a másik
szólamra.  Most ugyan nem esik egyik szólambeli hang másik szólambeli
szünetre, de ez tisztán véletlen: a megírt hangmagasságokból adódik,
nem a szünetek elhelyezéséből.
Mondhatni, az ütközések elkerülése Bach érdeme, nem a Finalé-é.

@end itemize

This example is not intended to suggest that Finale cannot be used to
produce publication-quality output.  On the contrary, in the hands of a
skilled user it can and does, but it requires skill and time.  One of the
fundamental differences between LilyPond and commercial scorewriters is
that LilyPond hopes to reduce the amount of human intervention to an
absolute minimum, while other packages try to provide an attractive
interface in which to make these types of edits.

One particularly glaring omission we found from Finale is a missing flat
in measure 33:

@quotation
@iftex
@sourceimage{pdf/bwv861mm33-34-annotate,7.93cm,}
@end iftex
@ifnottex
@sourceimage{bwv861mm33-34-annotate,,}
@end ifnottex
@end quotation

@noindent
The flat symbol is required to cancel out the natural in the same
measure, but Finale misses it because it occurred in a different voice.
So in addition to running a beaming plug-in and checking the spacing on
the noteheads and rests, the user must also check each measure for
cross-voice accidentals to avoid interrupting a rehearsal over an
engraving error.

If you are interested in examining these examples in more detail, the
full seven-measure excerpt can be found at the end of this essay along
with four different published engravings.  Close examination reveals that
there is some acceptable variation among the hand-engravings, but that
LilyPond compares reasonably well to that acceptable range.  There are
still some shortcomings in the LilyPond output, for example, it appears
a bit too aggressive in shortening some of the stems, so there is room
for further development and fine-tuning.

Of course, typography relies on human judgment of appearance, so people
cannot be replaced completely.  However, much of the dull work can be
automated.  If LilyPond solves most of the common situations correctly,
this will be a huge improvement over existing software.  Over the course
of years, the software can be refined to do more and more things
automatically, so manual overrides are less and less necessary.  Where
manual adjustments are needed, LilyPond's structure has been designed
with that flexibility in mind.

@node Building software
@section Building software

This section describes some of the programming decisions that we made
when designing LilyPond.

@menu
* Music representation::
* What symbols to engrave?::
* Flexible architecture::
@end menu


@node Music representation
@unnumberedsubsec Music representation

@cindex syntax
@cindex recursive structures

Ideally, the input format for any high-level formatting system is
an abstract description of the content.  In this case, that would
be the music itself.  This poses a formidable problem: how can we
define what music really is? Instead of trying to find an answer,
we have reversed the question.  We write a program capable of
producing sheet music, and adjust the format to be as lean as
possible.  When the format can no longer be trimmed down, by
definition we are left with content itself.  Our program serves as
a formal definition of a music document.

The syntax is also the user-interface for LilyPond, hence it is
easy to type:

@example
@{
  c'4 d'8
@}
@end example

@noindent
to create a quarter note on middle C (C1) and an eighth note on
the D above middle C (D1).

@lilypond[quote]
{
  c'4 d'8
}
@end lilypond

On a microscopic scale, such syntax is easy to use.  On a larger
scale, syntax also needs structure.  How else can you enter
complex pieces like symphonies and operas?  The structure is
formed by the concept of music expressions: by combining small
fragments of music into larger ones, more complex music can be
expressed.  For example

@lilypond[quote,verbatim,fragment,relative=1]
f4
@end lilypond

@noindent
Simultaneous notes can be constructed by enclosing them with
@code{<<} and @code{>>}:

@example
<<c4 d4 e4>>
@end example

@lilypond[quote,fragment,relative=1]
\new Voice { <<c4 d4 e>> }
@end lilypond

@noindent
This expression is put in sequence by enclosing it in curly braces
@code{@{@tie{}@dots{}@tie{}@}}:

@example
@{ f4 <<c4 d4 e4>> @}
@end example

@lilypond[quote,relative=1,fragment]
{ f4 <<c d e4>> }
@end lilypond

@noindent
The above is also an expression, and so it may be combined again
with another simultaneous expression (a half note) using
@code{<<}, @code{\\}, and @code{>>}:

@example
<< g2 \\ @{ f4 <<c4 d4 e4>> @} >>
@end example

@lilypond[quote,fragment,relative=2]
\new Voice { << g2 \\ { f4 <<c d e>> } >> }
@end lilypond

Such recursive structures can be specified neatly and formally in
a context-free grammar.  The parsing code is also generated from
this grammar.  In other words, the syntax of LilyPond is clearly
and unambiguously defined.

User-interfaces and syntax are what people see and deal with most.
They are partly a matter of taste, and also the subject of much
discussion.  Although discussions on taste do have their merit,
they are not very productive.  In the larger picture of LilyPond,
the importance of input syntax is small: inventing neat syntax is
easy, while writing decent formatting code is much harder.  This
is also illustrated by the line-counts for the respective
components: parsing and representation take up less than 10% of
the source code.

When designing the structures used in LilyPond, we made some different
decisions than are apparent in other software.  Consider the hierarchical
nature of music notation:

@lilypond[quote,fragment]
<<
  \new Staff \relative {
    \key g \major
    \time 3/4
    d''4 g,8 a b c d4 g, g
  }
  \new Staff \relative {
    \clef "bass"
    \key g \major
    <g b d>2 a4 b2.
  }
>>
@end lilypond

In this case, there are pitches grouped into chords that belong to
measures, which belong to staves.  This resembles a tidy structure of
nested boxes:

@quotation
@iftex
@sourceimage{pdf/nestedboxes,,4cm}
@end iftex
@ifnottex
@sourceimage{nestedboxes,,}
@end ifnottex
@end quotation

Unfortunately, the structure is tidy because it is based on some
excessively restrictive assumptions.  This becomes apparent if we
consider a more complicated musical example:

@lilypond[quote]
\layout {
  \context {
    \Score
    \remove Timing_translator
  }
  \context {
    \Staff
    \consists Timing_translator
  }
}

\new PianoStaff <<
  \new Staff = "RH" <<
    \new Voice = "I" \relative {
      \time 3/4
      \voiceOne
      \tuplet 7/6 { g''8 g g g g g g }
      \oneVoice
      r4 <b,, fis' g bes> r4\fermata
    }
    \new Voice = "II" \relative {
      \voiceTwo
      c'4
      \tuplet 5/4 {
        <c ees>8 f g
        \change Staff = "LH" \oneVoice
        \stemUp g,( c}
      r4
      \override Stem.cross-staff = ##t
      \override Stem.length = #12
      <fis, b>) r\fermata
    }
  >>
  \new Staff = "LH" <<
    \new Voice = "III" \relative {
      \time 2/4
      \clef "bass"
      g4 \stopStaff s
      \startStaff s2*2
    }
  >>
>>
@end lilypond

In this example, staves start and stop at will, voices jump around
between staves, and the staves have different time signatures.  Many
software packages would struggle with reproducing this example because
they are built on the nested box structure.  With LilyPond, on the other
hand, we have tried to keep the input format and the structure as
flexible as possible.

@node What symbols to engrave?
@unnumberedsubsec What symbols to engrave?

@cindex engraving
@cindex typography
@cindex engraver
@cindex plug-in

The formatting process decides where to place symbols.  However,
this can only be done once it is decided @emph{what} symbols
should be printed -- in other words, what notation to use.

Common music notation is a system of recording music that has
evolved over the past 1000 years.  The form that is now in common
use dates from the early Renaissance.  Although the basic form
(i.e., note heads on a 5-line staff) has not changed, the details
still evolve to express the innovations of contemporary notation.
Hence, common music notation encompasses some 500 years of music.
Its applications range from monophonic melodies to monstrous
counterpoints for a large orchestra.

How can we get a grip on such a seven-headed beast, and force it
into the confines of a computer program?  Our solution is to break
up the problem of notation (as opposed to engraving, i.e.,
typography) into digestible and programmable chunks: every type of
symbol is handled by a separate module, a so-called plug-in.  Each
plug-in is completely modular and independent, so each can be
developed and improved separately.  Such plug-ins are called
@code{engraver}s, by analogy with craftsmen who translate musical
ideas to graphic symbols.

In the following example, we start out with a plug-in for note
heads, the @code{Note_heads_engraver}.

@lilypond[quote,ragged-right]
\include "en/included/engraver-example.ily"

\score {
  \topVoice
  \layout {
    \context {
      \Voice
      \remove Stem_engraver
      \remove Phrasing_slur_engraver
      \remove Slur_engraver
      \remove Script_engraver
      \remove New_fingering_engraver
      \remove Beam_engraver
      \remove Auto_beam_engraver
    }
    \context {
      \Staff
      \remove Accidental_engraver
      \remove Key_engraver
      \remove Clef_engraver
      \remove Bar_engraver
      \remove Time_signature_engraver
      \remove Staff_symbol_engraver
      \consists Pitch_squash_engraver
    }
  }
}
@end lilypond

@noindent
Then a @code{Staff_symbol_engraver} adds the staff,

@lilypond[quote,ragged-right]
\include "en/included/engraver-example.ily"

\score {
  \topVoice
  \layout {
    \context {
      \Voice
      \remove Stem_engraver
      \remove Phrasing_slur_engraver
      \remove Slur_engraver
      \remove Script_engraver
      \remove New_fingering_engraver
      \remove Beam_engraver
      \remove Auto_beam_engraver
    }
    \context {
      \Staff
      \remove Accidental_engraver
      \remove Key_engraver
      \remove Clef_engraver
      \remove Bar_engraver
      \consists Pitch_squash_engraver
      \remove Time_signature_engraver
    }
  }
}
@end lilypond

@noindent
the @code{Clef_engraver} defines a reference point for the staff,

@lilypond[quote,ragged-right]
\include "en/included/engraver-example.ily"

\score {
  \topVoice
  \layout {
    \context {
      \Voice
      \remove Stem_engraver
      \remove Phrasing_slur_engraver
      \remove Slur_engraver
      \remove Script_engraver
      \remove New_fingering_engraver
      \remove Beam_engraver
      \remove Auto_beam_engraver
    }
    \context {
      \Staff
      \remove Accidental_engraver
      \remove Key_engraver
      \remove Bar_engraver
      \remove Time_signature_engraver
    }
  }
}
@end lilypond

@noindent
and the @code{Stem_engraver} adds stems.

@lilypond[quote,ragged-right]
\include "en/included/engraver-example.ily"

\score {
  \topVoice
  \layout {
    \context {
      \Voice
      \remove Phrasing_slur_engraver
      \remove Slur_engraver
      \remove Script_engraver
      \remove New_fingering_engraver
      \remove Beam_engraver
      \remove Auto_beam_engraver
    }
    \context {
      \Staff
      \remove Accidental_engraver
      \remove Key_engraver
      \remove Bar_engraver
      \remove Time_signature_engraver
    }
  }
}
@end lilypond

@noindent
The @code{Stem_engraver} is notified of any note head coming
along.  Every time one (or more, for a chord) note head is seen, a
stem object is created and connected to the note head.  By adding
engravers for beams, slurs, accents, accidentals, bar lines, time
signature, and key signature, we get a complete piece of notation.

@lilypond[quote,ragged-right]
\include "en/included/engraver-example.ily"
\score { \topVoice }
@end lilypond

@cindex polyphony
@cindex engraving multiple voices
@cindex contexts

This system works well for monophonic music, but what about
polyphony?  In polyphonic notation, many voices can share a staff.

@lilypond[quote,ragged-right]
\include "en/included/engraver-example.ily"
\new Staff << \topVoice \\ \botVoice >>
@end lilypond

In this situation, the accidentals and staff are shared, but the
stems, slurs, beams, etc., are private to each voice.  Hence,
engravers should be grouped.  The engravers for note heads, stems,
slurs, etc., go into a group called @q{Voice context}, while the
engravers for key, accidental, bar, etc., go into a group called
@q{Staff context}.  In the case of polyphony, a single Staff
context contains more than one Voice context.  Similarly, multiple
Staff contexts can be put into a single Score context.  The Score
context is the top level notation context.

@lilypond[quote,ragged-right]
\include "en/included/engraver-example.ily"
\score {
   <<
      \new Staff << \topVoice \\ \botVoice >>
      \new Staff << \pah \\ \hoom >>
   >>
}
@end lilypond

@morerefs
Internals Reference:
@rinternals{Contexts}.

@node Flexible architecture
@unnumberedsubsec Flexible architecture

When we started, we wrote the LilyPond program entirely in the C++
programming language; the program's functionality was set in stone
by the developers.  That proved to be unsatisfactory for a number
of reasons:

@itemize

@item When LilyPond makes mistakes, users need to override
formatting decisions.  Therefore, the user must have access to the
formatting engine.  Hence, rules and settings cannot be fixed by
us at compile-time but must be accessible for users at run-time.

@item Engraving is a matter of visual judgment, and therefore a
matter of taste.  As knowledgeable as we are, users can disagree
with our personal decisions.  Therefore, the definitions of
typographical style must also be accessible to the user.

@item Finally, we continually refine the formatting algorithms, so
we need a flexible approach to rules.  The C++ language forces a
certain method of grouping rules that cannot readily be applied to
formatting music notation.

@end itemize

@cindex Scheme programming language

These problems have been addressed by integrating an interpreter
for the Scheme programming language and rewriting parts of
LilyPond in Scheme.  The current formatting architecture is built
around the notion of graphical objects, described by Scheme
variables and functions.  This architecture encompasses formatting
rules, typographical style and individual formatting decisions.
The user has direct access to most of these controls.

Scheme variables control layout decisions.  For example, many
graphical objects have a direction variable that encodes the
choice between up and down (or left and right).  Here you see two
chords, with accents and arpeggios.  In the first chord, the
graphical objects have all directions down (or left).  The second
chord has all directions up (right).

@lilypond[quote,ragged-right]
\score {
  \relative {
    \stemDown <e' g b>4_>-\arpeggio
    \override Arpeggio.direction = #RIGHT
    \stemUp <e g b>4^>-\arpeggio
  }
  \layout {
    \context {
      \Score
      \override SpacingSpanner.spacing-increment = #3
      \hide TimeSignature
    }
  }
}
@end lilypond

@cindex score formatting
@cindex formatting a score
@cindex formatting rules

@noindent
The process of formatting a score consists of reading and writing
the variables of graphical objects.  Some variables have a preset
value.  For example, the thickness of many lines -- a
characteristic of typographical style -- is a variable with a
preset value.  You are free to alter this value, giving your score
a different typographical impression.

@lilypond[quote,ragged-right]
fragment = {
   \clef bass f8 as8
   c'4-~ c'16 as g f e16 g bes c' des'4
}
<<
   \new Staff \fragment
   \new Staff \with {
      \override Beam.beam-thickness = #0.3
      \override Stem.thickness = #0.5
      \override Bar.thickness = #3.6
      \override Tie.thickness = #2.2
      \override StaffSymbol.thickness = #3.0
      \override Tie.extra-offset = #'(0 .  0.3)
      }
      \fragment
>>
@end lilypond

Formatting rules are also preset variables: each object has
variables containing procedures.  These procedures perform the
actual formatting, and by substituting different ones, we can
change the appearance of objects.  In the following example, the
rule governing which note head objects are used to produce the
note head symbol is changed during the music fragment.

@lilypond[quote,ragged-right]
#(set-global-staff-size 30)

#(define (mc-squared grob orig current)
  (let* ((interfaces (ly:grob-interfaces grob))
         (pos (ly:grob-property grob 'staff-position)))
    (if (memq 'note-head-interface interfaces)
        (begin
          (ly:grob-set-property! grob 'stencil
            (grob-interpret-markup grob
              (make-lower-markup 0.5
                (case pos
                  ((-5) "m")
                  ((-3) "c ")
                  ((-2) (make-smaller-markup (make-bold-markup "2")))
                  (else "bla")))))))))

\new Voice \relative {
  \stemUp
  \set autoBeaming = ##f
  \time 2/4
  <d' f g>4
  \once \override NoteHead.stencil = #note-head::brew-ez-stencil
  \once \override NoteHead.font-size = #-7
  \once \override NoteHead.font-family = #'sans
  \once \override NoteHead.font-series = #'bold
  <d f g>4
  \once \override NoteHead.style = #'cross
  <d f g>4
  \applyOutput Voice #mc-squared
  <d f g>4
  <<
    { d8[ es-( fis^^ g] fis2-) }
    \repeat unfold 5 { \applyOutput Voice #mc-squared s8 }
  >>
}
@end lilypond



@node Putting LilyPond to work
@section Putting LilyPond to work

@cindex simple examples
@cindex examples, simple

We have written LilyPond as an experiment of how to condense the
art of music engraving into a computer program.  Thanks to all
that hard work, the program can now be used to perform useful
tasks.  The simplest application is printing notes.

@lilypond[quote,relative=1]
{
  \time 2/4
  c4 c g'4 g a4 a g2
}
@end lilypond

@noindent
By adding chord names and lyrics we obtain a lead sheet.

@lilypond[quote,ragged-right]
<<
   \chords { c2 c f2 c }
   \new Staff
   \relative {
     \time 2/4
     c'4 c g' g a a g2
   }
   \addlyrics { twin -- kle twin -- kle lit -- tle star }
>>
@end lilypond

Polyphonic notation and piano music can also be printed.  The
following example combines some more exotic constructs.

@lilypond[quote,line-width=15.9\cm]
\header {
  title = "Screech and boink"
  subtitle = "Random complex notation"
  composer = "Han-Wen Nienhuys"
}

\score {
  \context PianoStaff <<
    \new Staff = "up" {
      \time 4/8
      \key c \minor
      << {
        \revert Stem.direction
        \change Staff = down
        \set subdivideBeams = ##t
        g16.[
          \change Staff = up
          c'''32
          \change Staff = down
          g32
          \change Staff = up
          c'''32
          \change Staff = down
          g16]
        \change Staff = up
        \stemUp
        \set followVoice = ##t
        c'''32([ b''16 a''16 gis''16 g''32)]
      } \\ {
        s4 \tuplet 3/2 { d'16[ f' g'] } as'32[ b''32 e'' d'']
      } \\ {
        s4 \autoBeamOff d''8.. f''32
      } \\ {
        s4 es''4
      } >>
    }

    \new Staff = "down" {
      \clef bass
      \key c \minor
      \set subdivideBeams = ##f
      \override Stem.french-beaming = ##t
      \override Beam.beam-thickness = #0.3
      \override Stem.thickness = #4.0
      g'16[ b16 fis16 g16]
      << \makeClusters {
        as16 <as b>
        <g b>
        <g cis>
      } \\ {
        \override Staff.Arpeggio.arpeggio-direction =#down
        <cis, e, gis, b, cis>4\arpeggio
      }
    >> }
  >>
  \midi {
    \tempo 8 = 60
  }
  \layout {
    \context {
      \Staff
      \consists Horizontal_bracket_engraver
    }
  }
}
@end lilypond

The fragments shown above have all been written by hand, but that
is not a requirement.  Since the formatting engine is mostly
automatic, it can serve as an output means for other programs that
manipulate music.  For example, it can also be used to convert
databases of musical fragments to images for use on websites and
multimedia presentations.

This manual also shows an application: the input format is text, and can
therefore be easily embedded in other text-based formats such as
@LaTeX{}, HTML, or in the case of this manual, Texinfo.  Using the
@command{lilypond-book} program, included with LilyPond, the input
fragments can be replaced by music images in the resulting PDF or HTML
output files.  Another example is the third-party OOoLilyPond extension
for OpenOffice.org or LibreOffice, which makes it extremely easy to
embed musical examples in documents.

For more examples of LilyPond in action, full documentation, and the
software itself, see our main website: www.lilypond.org.

@page
@node Engraved examples (BWV 861)
@section Engraved examples (BWV 861)

This section contains four reference engravings and two
software-engraved versions of Bach's Fugue in G minor from the
Well-Tempered Clavier, Book I, BWV 861 (the last seven measures).

@noindent
Bärenreiter BA5070 (Neue Ausgabe Sämtlicher Werke, Serie V, Band 6.1,
1989):

@iftex
@sourceimage{bwv861-baer,16cm,}
@end iftex
@ifnottex
@sourceimage{bwv861-baer-small,,}
@end ifnottex

@noindent
Bärenreiter BA5070 (Neue Ausgabe Sämtlicher Werke, Serie V, Band 6.1,
1989), an alternate musical source.  Aside from the textual differences,
this demonstrates slight variations in the engraving decisions, even
from the same publisher and edition:

@iftex
@sourceimage{bwv861-baer-alt,16cm,}
@end iftex
@ifnottex
@sourceimage{bwv861-baer-alt-small,,}
@end ifnottex

@noindent
Breitkopf & Härtel, edited by Ferruccio Busoni (Wiesbaden, 1894), also
available from the Petrucci Music Library (IMSLP #22081).  The editorial
markings (fingerings, articulations, etc.) have been removed for clearer
comparison with the other editions here:

@iftex
@sourceimage{bwv861-breitkopf,16cm,}
@end iftex
@ifnottex
@sourceimage{bwv861-breitkopf-small,,}
@end ifnottex

@noindent
Bach-Gesellschaft edition (Leipzig, 1866), available from the Petrucci
Music Library (IMSPL #02221):

@iftex
@sourceimage{bwv861-gesellschaft,16cm,}
@end iftex
@ifnottex
@sourceimage{bwv861-gesellschaft-small,,}
@end ifnottex

@noindent
Finale 2008:

@iftex
@sourceimage{pdf/bwv861-finale2008a,,}
@end iftex
@ifnottex
@sourceimage{bwv861-finale2008a,,}
@end ifnottex

@sp 4
@noindent
LilyPond, version @version{}:

@lilypond[staffsize=14.3,line-width=15.9\cm]
global = {\key g \minor}

partI = \relative {
  \voiceOne
  fis'8 d' ees g, fis4 g
  r8 a16 bes c8 bes16 a d8 r r4
  r2 r8 d16 ees f8 ees16 d
  ees4 ~ 16 d c bes a4 r8 ees'16 d
  c8 d16 ees d8 e16 fis g8 fis16 g a4 ~
  8 d, g f ees d c bes
  a2 g\fermata \bar "|."
}

partII = \relative {
  \voiceTwo
  d'4 r4 r8 d'16 c bes8 c16 d
  ees8 d c ees a, r r4
  r8 fis16 g a8 g16 fis g2 ~
  2 r8 d' ees g,
  fis4 g r8 a16 bes c8 bes16 a
  bes4. <g b>8 <a c> r <d, g> r
  <ees g>4 <d fis> d2
}
partIII = \relative {
  \voiceOne
  r2 r8 d' ees g, fis4 g r8 a16 bes c8 bes16 a
  bes2 ~ 8 b16 a g8 a16 b
  c4 r r2
  R1
  r8 d ees g, fis4 g
  r8 a16 bes c8 bes16 a b2
}
partIV = \relative {
  \voiceTwo
  d4 r r2
  r8 d ees g, fis4 a
  d,8 d'16 c bes8 c16 d ees2 ~
  8 ees16 d c8 d16 ees fis,8 a16 g fis8 g16 a
  d,8 d'16 c bes8 c16 d ees8 c a fis'
  g f ees d c bes a g
  c a d d, g2\fermata
}

\score {
  <<
    \set Score.currentBarNumber = #28
    \new PianoStaff <<
      \new Staff = "RH" <<
        \global
        \new Voice = "voiceI" { \partI }
        \new Voice = "voiceII" { \partII }
      >>

      \new Staff = "LH" <<
        \clef "bass"
        \global
        \new Voice = "voiceIII" { \partIII }
        \new Voice = "voiceIV" { \partIV }
      >>
    >>
  >>
  \layout {
    \context {
      \Staff
      \remove Time_signature_engraver
    }
    \context {
      \PianoStaff
      \override StaffGrouper.staff-staff-spacing.padding = #1
    }
  }
}
@end lilypond
